"use strict";(self.webpackChunkdemo_maps=self.webpackChunkdemo_maps||[]).push([[185],{1185:(Lt,A,f)=>{f.r(A),f.d(A,{RouteExampleThreejsModule:()=>dt,RouteExampleThreejsRoutingModule:()=>z});var H=f(6610),X=f(7925),T=f(1686),C=f(5857),U=f(6591),$=f(1688),J=f(9557),Y=f(1540),W=f(4249),N=f(8654),F=f(5409),I=f(9380),B=f(730),Q=f(9346),K=f(6370),b=f(8507),v=f(9973),V=f(5085),w=f(9325),Z=f(7915);function G(g,t,e){const n=[];let a=g(0),s=g(1),i=t(a),o=t(s);const L=[s,a],_=[o,i],d=[1,0],r={};let y,h,m,p,c,S,u=1e5;for(;--u>0&&d.length>0;)m=d.pop(),a=L.pop(),i=_.pop(),S=m.toString(),S in r||(n.push(i[0],i[1]),r[S]=!0),p=d.pop(),s=L.pop(),o=_.pop(),c=(m+p)/2,y=g(c),h=t(y),(0,v.Q1)(h[0],h[1],i[0],i[1],o[0],o[1])<e?(n.push(o[0],o[1]),S=p.toString(),r[S]=!0):(d.push(p,c,c,m),_.push(o,h,h,i),L.push(s,y,y,a));return n}const tt=new F.A({color:"rgba(0,0,0,0.2)"}),et=[90,45,30,20,10,5,2,1,.5,20/60,10/60,5/60,2/60,1/60,30/3600,20/3600,10/3600,5/3600,2/3600,1/3600],it=class at extends Q.A{constructor(t){t=t||{};const e=Object.assign({updateWhileAnimating:!0,updateWhileInteracting:!0,renderBuffer:0},t);delete e.maxLines,delete e.strokeStyle,delete e.targetSize,delete e.showLabels,delete e.lonLabelFormatter,delete e.latLabelFormatter,delete e.lonLabelPosition,delete e.latLabelPosition,delete e.lonLabelStyle,delete e.latLabelStyle,delete e.intervals,super(e),this.projection_=null,this.maxLat_=1/0,this.maxLon_=1/0,this.minLat_=-1/0,this.minLon_=-1/0,this.maxX_=1/0,this.maxY_=1/0,this.minX_=-1/0,this.minY_=-1/0,this.targetSize_=void 0!==t.targetSize?t.targetSize:100,this.maxLines_=void 0!==t.maxLines?t.maxLines:100,this.meridians_=[],this.parallels_=[],this.strokeStyle_=void 0!==t.strokeStyle?t.strokeStyle:tt,this.fromLonLatTransform_=void 0,this.toLonLatTransform_=void 0,this.projectionCenterLonLat_=null,this.bottomLeft_=null,this.bottomRight_=null,this.topLeft_=null,this.topRight_=null,this.meridiansLabels_=null,this.parallelsLabels_=null,t.showLabels&&(this.lonLabelFormatter_=null==t.lonLabelFormatter?V.aP.bind(this,"EW"):t.lonLabelFormatter,this.latLabelFormatter_=null==t.latLabelFormatter?V.aP.bind(this,"NS"):t.latLabelFormatter,this.lonLabelPosition_=null==t.lonLabelPosition?0:t.lonLabelPosition,this.latLabelPosition_=null==t.latLabelPosition?1:t.latLabelPosition,this.lonLabelStyleBase_=new I.Ay({text:void 0!==t.lonLabelStyle?t.lonLabelStyle.clone():new B.A({font:"12px Calibri,sans-serif",textBaseline:"bottom",fill:new Y.A({color:"rgba(0,0,0,1)"}),stroke:new F.A({color:"rgba(255,255,255,1)",width:3})})}),this.lonLabelStyle_=n=>{const a=n.get("graticule_label");return this.lonLabelStyleBase_.getText().setText(a),this.lonLabelStyleBase_},this.latLabelStyleBase_=new I.Ay({text:void 0!==t.latLabelStyle?t.latLabelStyle.clone():new B.A({font:"12px Calibri,sans-serif",textAlign:"right",fill:new Y.A({color:"rgba(0,0,0,1)"}),stroke:new F.A({color:"rgba(255,255,255,1)",width:3})})}),this.latLabelStyle_=n=>{const a=n.get("graticule_label");return this.latLabelStyleBase_.getText().setText(a),this.latLabelStyleBase_},this.meridiansLabels_=[],this.parallelsLabels_=[],this.addEventListener($.A.POSTRENDER,this.drawLabels_.bind(this))),this.intervals_=void 0!==t.intervals?t.intervals:et,this.setSource(new K.A({loader:this.loaderFunction.bind(this),strategy:this.strategyFunction.bind(this),features:new U.A,overlaps:!1,useSpatialIndex:!1,wrapX:t.wrapX})),this.featurePool_=[],this.lineStyle_=new I.Ay({stroke:this.strokeStyle_}),this.loadedExtent_=null,this.renderedExtent_=null,this.renderedResolution_=null,this.setRenderOrder(null)}strategyFunction(t,e){let n=t.slice();return this.projection_&&this.getSource().getWrapX()&&(0,b.Li)(n,this.projection_),this.loadedExtent_&&((0,b.bE)(this.loadedExtent_,n,e)?n=this.loadedExtent_.slice():this.getSource().removeLoadedExtent(this.loadedExtent_)),[n]}loaderFunction(t,e,n){this.loadedExtent_=t;const a=this.getSource(),s=this.getExtent()||[-1/0,-1/0,1/0,1/0],i=(0,b._N)(s,t);if(this.renderedExtent_&&(0,b.aI)(this.renderedExtent_,i)&&this.renderedResolution_===e||(this.renderedExtent_=i,this.renderedResolution_=e,(0,b.Im)(i)))return;const o=(0,b.q1)(i),L=e*e/4;(!this.projection_||!(0,w.tI)(this.projection_,n))&&this.updateProjectionInfo_(n),this.createGraticule_(i,o,e,L);let r,d=this.meridians_.length+this.parallels_.length;for(this.meridiansLabels_&&(d+=this.meridians_.length),this.parallelsLabels_&&(d+=this.parallels_.length);d>this.featurePool_.length;)r=new J.A,this.featurePool_.push(r);const u=a.getFeaturesCollection();u.clear();let h,m,y=0;for(h=0,m=this.meridians_.length;h<m;++h)r=this.featurePool_[y++],r.setGeometry(this.meridians_[h]),r.setStyle(this.lineStyle_),u.push(r);for(h=0,m=this.parallels_.length;h<m;++h)r=this.featurePool_[y++],r.setGeometry(this.parallels_[h]),r.setStyle(this.lineStyle_),u.push(r)}addMeridian_(t,e,n,a,s,i){const o=this.getMeridian_(t,e,n,a,i);if((0,b.HY)(o.getExtent(),s)){if(this.meridiansLabels_){const L=this.lonLabelFormatter_(t);i in this.meridiansLabels_?this.meridiansLabels_[i].text=L:this.meridiansLabels_[i]={geom:new N.A([]),text:L}}this.meridians_[i++]=o}return i}addParallel_(t,e,n,a,s,i){const o=this.getParallel_(t,e,n,a,i);if((0,b.HY)(o.getExtent(),s)){if(this.parallelsLabels_){const L=this.latLabelFormatter_(t);i in this.parallelsLabels_?this.parallelsLabels_[i].text=L:this.parallelsLabels_[i]={geom:new N.A([]),text:L}}this.parallels_[i++]=o}return i}drawLabels_(t){const e=t.frameState.viewState.rotation,n=t.frameState.viewState.resolution,a=t.frameState.size,s=t.frameState.extent,i=(0,b.q1)(s);let o=s;if(e){const h=a[0]*n,m=a[1]*n;o=[i[0]-h/2,i[1]-m/2,i[0]+h/2,i[1]+m/2]}let L=0,_=0,d=this.latLabelPosition_<.5;const r=this.projection_.getExtent(),u=(0,b.RG)(r);this.getSource().getWrapX()&&this.projection_.canWrapX()&&!(0,b.ms)(r,s)&&(L=Math.floor((s[0]-r[0])/u),_=Math.ceil((s[2]-r[2])/u),d=d!==Math.abs(e)>Math.PI/2);const y=(0,Z.r2)(t);for(let h=L;h<=_;++h){let p,c,S,M,m=this.meridians_.length+this.parallels_.length;if(this.meridiansLabels_)for(c=0,S=this.meridiansLabels_.length;c<S;++c){const E=this.meridians_[c];if(e||0!==h){const x=E.clone();x.translate(h*u,0),x.rotate(-e,i),M=this.getMeridianPoint_(x,o,c),M.rotate(e,i)}else M=this.getMeridianPoint_(E,s,c);p=this.featurePool_[m++],p.setGeometry(M),p.set("graticule_label",this.meridiansLabels_[c].text),y.drawFeature(p,this.lonLabelStyle_(p))}if(this.parallelsLabels_&&(h===L&&d||h===_&&!d))for(c=0,S=this.parallels_.length;c<S;++c){const E=this.parallels_[c];if(e||0!==h){const x=E.clone();x.translate(h*u,0),x.rotate(-e,i),M=this.getParallelPoint_(x,o,c),M.rotate(e,i)}else M=this.getParallelPoint_(E,s,c);p=this.featurePool_[m++],p.setGeometry(M),p.set("graticule_label",this.parallelsLabels_[c].text),y.drawFeature(p,this.latLabelStyle_(p))}}}createGraticule_(t,e,n,a){const s=this.getInterval_(n);if(-1==s)return this.meridians_.length=0,this.parallels_.length=0,this.meridiansLabels_&&(this.meridiansLabels_.length=0),void(this.parallelsLabels_&&(this.parallelsLabels_.length=0));let i=!1;const o=this.projection_.getExtent(),L=(0,b.RG)(o);this.getSource().getWrapX()&&this.projection_.canWrapX()&&!(0,b.ms)(o,t)&&((0,b.RG)(t)>=L?(t[0]=o[0],t[2]=o[2]):i=!0);const _=[(0,v.qE)(e[0],this.minX_,this.maxX_),(0,v.qE)(e[1],this.minY_,this.maxY_)],d=this.toLonLatTransform_(_);isNaN(d[1])&&(d[1]=Math.abs(this.maxLat_)>=Math.abs(this.minLat_)?this.maxLat_:this.minLat_);let r=(0,v.qE)(d[0],this.minLon_,this.maxLon_),u=(0,v.qE)(d[1],this.minLat_,this.maxLat_);const y=this.maxLines_;let h,m,p,c,S=t;i||(S=[(0,v.qE)(t[0],this.minX_,this.maxX_),(0,v.qE)(t[1],this.minY_,this.maxY_),(0,v.qE)(t[2],this.minX_,this.maxX_),(0,v.qE)(t[3],this.minY_,this.maxY_)]);const M=(0,b.NW)(S,this.toLonLatTransform_,void 0,8);let E=M[3],x=M[2],j=M[1],R=M[0];if(i||((0,b.Ym)(S,this.bottomLeft_)&&(R=this.minLon_,j=this.minLat_),(0,b.Ym)(S,this.bottomRight_)&&(x=this.maxLon_,j=this.minLat_),(0,b.Ym)(S,this.topLeft_)&&(R=this.minLon_,E=this.maxLat_),(0,b.Ym)(S,this.topRight_)&&(x=this.maxLon_,E=this.maxLat_),E=(0,v.qE)(E,u,this.maxLat_),x=(0,v.qE)(x,r,this.maxLon_),j=(0,v.qE)(j,this.minLat_,u),R=(0,v.qE)(R,this.minLon_,r)),r=Math.floor(r/s)*s,c=(0,v.qE)(r,this.minLon_,this.maxLon_),m=this.addMeridian_(c,j,E,a,t,0),h=0,i)for(;(c-=s)>=R&&h++<y;)m=this.addMeridian_(c,j,E,a,t,m);else for(;c!=this.minLon_&&h++<y;)c=Math.max(c-s,this.minLon_),m=this.addMeridian_(c,j,E,a,t,m);if(c=(0,v.qE)(r,this.minLon_,this.maxLon_),h=0,i)for(;(c+=s)<=x&&h++<y;)m=this.addMeridian_(c,j,E,a,t,m);else for(;c!=this.maxLon_&&h++<y;)c=Math.min(c+s,this.maxLon_),m=this.addMeridian_(c,j,E,a,t,m);for(this.meridians_.length=m,this.meridiansLabels_&&(this.meridiansLabels_.length=m),u=Math.floor(u/s)*s,p=(0,v.qE)(u,this.minLat_,this.maxLat_),m=this.addParallel_(p,R,x,a,t,0),h=0;p!=this.minLat_&&h++<y;)p=Math.max(p-s,this.minLat_),m=this.addParallel_(p,R,x,a,t,m);for(p=(0,v.qE)(u,this.minLat_,this.maxLat_),h=0;p!=this.maxLat_&&h++<y;)p=Math.min(p+s,this.maxLat_),m=this.addParallel_(p,R,x,a,t,m);this.parallels_.length=m,this.parallelsLabels_&&(this.parallelsLabels_.length=m)}getInterval_(t){const e=this.projectionCenterLonLat_[0],n=this.projectionCenterLonLat_[1];let a=-1;const s=Math.pow(this.targetSize_*t,2),i=[],o=[];for(let L=0,_=this.intervals_.length;L<_;++L){const d=(0,v.qE)(this.intervals_[L]/2,0,90),r=(0,v.qE)(n,-90+d,90-d);if(i[0]=e-d,i[1]=r-d,o[0]=e+d,o[1]=r+d,this.fromLonLatTransform_(i,i),this.fromLonLatTransform_(o,o),Math.pow(o[0]-i[0],2)+Math.pow(o[1]-i[1],2)<=s)break;a=this.intervals_[L]}return a}getMeridian_(t,e,n,a,s){const i=function k(g,t,e,n,a){const s=(0,w.Jt)("EPSG:4326");return G(function(i){return[g,t+(e-t)*i]},(0,w.RG)(s,n),a)}(t,e,n,this.projection_,a);let o=this.meridians_[s];return o?(o.setFlatCoordinates("XY",i),o.changed()):(o=new W.A(i,"XY"),this.meridians_[s]=o),o}getMeridianPoint_(t,e,n){const a=t.getFlatCoordinates();let s=1,i=a.length-1;a[s]>a[i]&&(s=i,i=1);const o=Math.max(e[1],a[s]),L=Math.min(e[3],a[i]),_=(0,v.qE)(e[1]+Math.abs(e[1]-e[3])*this.lonLabelPosition_,o,L),u=this.meridiansLabels_[n].geom;return u.setCoordinates([a[s-1]+(a[i-1]-a[s-1])*(_-a[s])/(a[i]-a[s]),_]),u}getMeridians(){return this.meridians_}getParallel_(t,e,n,a,s){const i=function q(g,t,e,n,a){const s=(0,w.Jt)("EPSG:4326");return G(function(i){return[t+(e-t)*i,g]},(0,w.RG)(s,n),a)}(t,e,n,this.projection_,a);let o=this.parallels_[s];return o?(o.setFlatCoordinates("XY",i),o.changed()):o=new W.A(i,"XY"),o}getParallelPoint_(t,e,n){const a=t.getFlatCoordinates();let s=0,i=a.length-2;a[s]>a[i]&&(s=i,i=0);const o=Math.max(e[0],a[s]),L=Math.min(e[2],a[i]),_=(0,v.qE)(e[0]+Math.abs(e[0]-e[2])*this.latLabelPosition_,o,L),u=this.parallelsLabels_[n].geom;return u.setCoordinates([_,a[s+1]+(a[i+1]-a[s+1])*(_-a[s])/(a[i]-a[s])]),u}getParallels(){return this.parallels_}updateProjectionInfo_(t){const e=(0,w.Jt)("EPSG:4326"),n=t.getWorldExtent();this.maxLat_=n[3],this.maxLon_=n[2],this.minLat_=n[1],this.minLon_=n[0];const a=(0,w.RG)(t,e);if(this.minLon_<this.maxLon_)this.toLonLatTransform_=a;else{const i=this.minLon_+this.maxLon_/2;this.maxLon_+=360,this.toLonLatTransform_=function(o,L,_){const d=a(o,L,_=_||2);for(let r=0,u=d.length;r<u;r+=_)d[r]<i&&(d[r]+=360);return d}}this.fromLonLatTransform_=(0,w.RG)(e,t);const s=(0,b.NW)([this.minLon_,this.minLat_,this.maxLon_,this.maxLat_],this.fromLonLatTransform_,void 0,8);this.minX_=s[0],this.maxX_=s[2],this.minY_=s[1],this.maxY_=s[3],this.bottomLeft_=this.fromLonLatTransform_([this.minLon_,this.minLat_]),this.bottomRight_=this.fromLonLatTransform_([this.maxLon_,this.minLat_]),this.topLeft_=this.fromLonLatTransform_([this.minLon_,this.maxLat_]),this.topRight_=this.fromLonLatTransform_([this.maxLon_,this.maxLat_]),this.projectionCenterLonLat_=this.toLonLatTransform_((0,b.q1)(t.getExtent())),isNaN(this.projectionCenterLonLat_[1])&&(this.projectionCenterLonLat_[1]=Math.abs(this.maxLat_)>=Math.abs(this.minLat_)?this.maxLat_:this.minLat_),this.projection_=t}};var st=f(1888),nt=f(8201),ot=f(3982),lt=f(479),rt=f(8299),O=f(5812),P=f(213),ht=f(3522),l=f(3279),ct=f(6478);ot.h.addIcons(lt.Q,rt.V);let D=(()=>{class g{constructor(e,n,a,s){this.layersSvc=e,this.mapStateSvc=n,this.mapOlSvc=a,this.mapThreeSvc=s,this.class="content-container",this.controls={attribution:!0,mousePosition:!0,scaleLine:!0,zoom:!0}}ngOnInit(){const e=new nt.A({source:new st.A({url:"https://planetarymaps.usgs.gov/cgi-bin/mapserv?map=/maps/mars/phobos_simp_cyl.map",params:{LAYERS:"VIKING"},crossOrigin:"anonymous"})}),n=new it({showLabels:!0,wrapX:!0,latLabelPosition:.5}),a=new T.tr({id:"phobos",name:"Phobos",custom_layer:e,description:"There are a few objects that are very big, but still irregularly shaped.\n      Because they are big, it makes sense to serve their image-material per WMTS instead of a single, humongous file.\n      Because they are irregularly shaped, it makes sense to display them in 3d.\n\n      This demo shows how we can project openlayers-layers onto a three-js mesh to reap the benefits of both libraries."}),s=new T.tr({id:"graticule",name:"Graticule",custom_layer:n,description:"Note how adding and removing this layer is reflected in both the map and the 3d-object."});this.layersSvc.addLayer(a),this.layersSvc.addLayer(s)}ngAfterViewInit(){const e=(0,w.Jt)("EPSG:4326");this.mapOlSvc.setProjection(e),this.mapOlSvc.map.getView().setMaxZoom(4)}static{this.\u0275fac=function(n){return new(n||g)(l.rXU(T._t),l.rXU(ct.d),l.rXU(C.t),l.rXU(O.Cx))}}static{this.\u0275cmp=l.VBU({type:g,selectors:[["app-route-example-threejs"]],hostVars:2,hostBindings:function(n,a){2&n&&l.HbH(a.class)},standalone:!0,features:[l.Jv_([T._t,C.t]),l.aNF],decls:25,vars:10,consts:[[1,"content-area","map-view"],[2,"height","49.5%","width","100%"],["id","olMap",3,"layersSvc","mapState","controls"],[2,"height","50%","width","100%"],["id","threeMap",3,"mapOlSvc"],[1,"right",3,"clrVerticalNavCollapsible","clr-nav-level"],[1,"layers",3,"clrVerticalNavGroupExpanded"],["shape","info-standard","clrVerticalNavIcon","","title","layers"],[1,"padding","title-ellipsis"],[1,"card",2,"margin","0px","margin-bottom","10px"],[1,"card-block"],[1,"card-text"],["shape","layers","clrVerticalNavIcon","","title","layers"],[1,"alert-item","static"],[1,"alert-text"],[3,"layersSvc","mapStateSvc"]],template:function(n,a){1&n&&(l.j41(0,"main",0)(1,"div",1),l.nrm(2,"ukis-map-ol",2),l.k0s(),l.j41(3,"div",3),l.nrm(4,"ukis-map-three",4),l.k0s()(),l.j41(5,"clr-vertical-nav",5)(6,"clr-vertical-nav-group",6),l.nrm(7,"cds-icon",7),l.EFF(8," Phobos "),l.j41(9,"clr-vertical-nav-group-children",8)(10,"div",9)(11,"div",10)(12,"div",11)(13,"p"),l.EFF(14," This is a threejs/openlayers demo application. Here, we project an openlayers map as a canvas-texture onto a glTF model of the Mars-moon Phobos. "),l.k0s(),l.j41(15,"p"),l.EFF(16," There are some objects that are so irregular that they are better displayed with a three dimensional model, yet so large that their imagedata is best served per WMTS. Phobos is a good example of such an object. Note how the texture gets sharper when you zoom in: this is a new WMTS tile being loaded, projected and displayed on the fly. "),l.k0s()()()()()(),l.j41(17,"clr-vertical-nav-group",6),l.nrm(18,"cds-icon",12),l.EFF(19," Layers "),l.j41(20,"clr-vertical-nav-group-children",8)(21,"div",13)(22,"span",14),l.EFF(23," The controls of map and 3d-object are synced. Use the mouse to pan around in either and watch both displays change. "),l.k0s()(),l.nrm(24,"ukis-layer-control",15),l.k0s()()()),2&n&&(l.R7$(2),l.Y8G("layersSvc",a.layersSvc)("mapState",a.mapStateSvc)("controls",a.controls),l.R7$(2),l.Y8G("mapOlSvc",a.mapOlSvc),l.R7$(),l.Y8G("clrVerticalNavCollapsible",!0)("clr-nav-level",2),l.R7$(),l.Y8G("clrVerticalNavGroupExpanded",!0),l.R7$(11),l.Y8G("clrVerticalNavGroupExpanded",!0),l.R7$(7),l.Y8G("layersSvc",a.layersSvc)("mapStateSvc",a.mapStateSvc))},dependencies:[C.L,O.sc,P.HEs,P.D2I,P.wqM,P.zLy,P.Wfw,P.BlU,P.Qmr,P.ndX,P.Lfk,P.SVK,P.tQl,ht.Sj]})}}return g})();const mt=[{path:"",component:D}];let z=(()=>{class g{static{this.\u0275fac=function(n){return new(n||g)}}static{this.\u0275mod=l.$C({type:g})}static{this.\u0275inj=l.G2t({imports:[X.iI.forChild(mt),X.iI]})}}return g})(),dt=(()=>{class g{static{this.\u0275fac=function(n){return new(n||g)}}static{this.\u0275mod=l.$C({type:g})}static{this.\u0275inj=l.G2t({imports:[H.MD,z,P.PuD,D]})}}return g})()}}]);