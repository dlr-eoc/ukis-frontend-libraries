"use strict";(self.webpackChunkdemo_maps=self.webpackChunkdemo_maps||[]).push([[395],{4395:(ut,X,L)=>{L.r(X),L.d(X,{RouteExampleThreejsModule:()=>Lt,RouteExampleThreejsRoutingModule:()=>O});var U=L(3223),V=L(9498),B=L(1794),C=L(2474),w=L(9631),D=L(7934),J=L(5603),K=L(7176),A=L(2334),W=L(49),Y=L(8095),I=L(5784),R=L(9032),G=L(5739),Q=L(5616),H=L(1308),b=L(77),v=L(6868),N=L(63),E=L(7704),$=L(1963);function F(g,t,e){const n=[];let a=g(0),s=g(1),i=t(a),o=t(s);const u=[s,a],_=[o,i],d=[1,0],r={};let S,h,m,f,c,y,p=1e5;for(;--p>0&&d.length>0;)m=d.pop(),a=u.pop(),i=_.pop(),y=m.toString(),y in r||(n.push(i[0],i[1]),r[y]=!0),f=d.pop(),s=u.pop(),o=_.pop(),c=(m+f)/2,S=g(c),h=t(S),(0,v.rU)(h[0],h[1],i[0],i[1],o[0],o[1])<e?(n.push(o[0],o[1]),y=f.toString(),r[y]=!0):(d.push(f,c,c,m),_.push(o,h,h,i),u.push(s,S,S,a));return n}const tt=new I.Z({color:"rgba(0,0,0,0.2)"}),et=[90,45,30,20,10,5,2,1,.5,20/60,10/60,5/60,2/60,1/60,30/3600,20/3600,10/3600,5/3600,2/3600,1/3600],it=class at extends Q.Z{constructor(t){t=t||{};const e=Object.assign({updateWhileAnimating:!0,updateWhileInteracting:!0,renderBuffer:0},t);delete e.maxLines,delete e.strokeStyle,delete e.targetSize,delete e.showLabels,delete e.lonLabelFormatter,delete e.latLabelFormatter,delete e.lonLabelPosition,delete e.latLabelPosition,delete e.lonLabelStyle,delete e.latLabelStyle,delete e.intervals,super(e),this.projection_=null,this.maxLat_=1/0,this.maxLon_=1/0,this.minLat_=-1/0,this.minLon_=-1/0,this.maxX_=1/0,this.maxY_=1/0,this.minX_=-1/0,this.minY_=-1/0,this.targetSize_=void 0!==t.targetSize?t.targetSize:100,this.maxLines_=void 0!==t.maxLines?t.maxLines:100,this.meridians_=[],this.parallels_=[],this.strokeStyle_=void 0!==t.strokeStyle?t.strokeStyle:tt,this.fromLonLatTransform_=void 0,this.toLonLatTransform_=void 0,this.projectionCenterLonLat_=null,this.bottomLeft_=null,this.bottomRight_=null,this.topLeft_=null,this.topRight_=null,this.meridiansLabels_=null,this.parallelsLabels_=null,t.showLabels&&(this.lonLabelFormatter_=null==t.lonLabelFormatter?N.I8.bind(this,"EW"):t.lonLabelFormatter,this.latLabelFormatter_=null==t.latLabelFormatter?N.I8.bind(this,"NS"):t.latLabelFormatter,this.lonLabelPosition_=null==t.lonLabelPosition?0:t.lonLabelPosition,this.latLabelPosition_=null==t.latLabelPosition?1:t.latLabelPosition,this.lonLabelStyleBase_=new R.ZP({text:void 0!==t.lonLabelStyle?t.lonLabelStyle.clone():new G.Z({font:"12px Calibri,sans-serif",textBaseline:"bottom",fill:new A.Z({color:"rgba(0,0,0,1)"}),stroke:new I.Z({color:"rgba(255,255,255,1)",width:3})})}),this.lonLabelStyle_=n=>{const a=n.get("graticule_label");return this.lonLabelStyleBase_.getText().setText(a),this.lonLabelStyleBase_},this.latLabelStyleBase_=new R.ZP({text:void 0!==t.latLabelStyle?t.latLabelStyle.clone():new G.Z({font:"12px Calibri,sans-serif",textAlign:"right",fill:new A.Z({color:"rgba(0,0,0,1)"}),stroke:new I.Z({color:"rgba(255,255,255,1)",width:3})})}),this.latLabelStyle_=n=>{const a=n.get("graticule_label");return this.latLabelStyleBase_.getText().setText(a),this.latLabelStyleBase_},this.meridiansLabels_=[],this.parallelsLabels_=[],this.addEventListener(J.Z.POSTRENDER,this.drawLabels_.bind(this))),this.intervals_=void 0!==t.intervals?t.intervals:et,this.setSource(new H.Z({loader:this.loaderFunction.bind(this),strategy:this.strategyFunction.bind(this),features:new D.Z,overlaps:!1,useSpatialIndex:!1,wrapX:t.wrapX})),this.featurePool_=[],this.lineStyle_=new R.ZP({stroke:this.strokeStyle_}),this.loadedExtent_=null,this.renderedExtent_=null,this.renderedResolution_=null,this.setRenderOrder(null)}strategyFunction(t,e){let n=t.slice();return this.projection_&&this.getSource().getWrapX()&&(0,b.Cf)(n,this.projection_),this.loadedExtent_&&((0,b.iW)(this.loadedExtent_,n,e)?n=this.loadedExtent_.slice():this.getSource().removeLoadedExtent(this.loadedExtent_)),[n]}loaderFunction(t,e,n){this.loadedExtent_=t;const a=this.getSource(),s=this.getExtent()||[-1/0,-1/0,1/0,1/0],i=(0,b.Ed)(s,t);if(this.renderedExtent_&&(0,b.fS)(this.renderedExtent_,i)&&this.renderedResolution_===e||(this.renderedExtent_=i,this.renderedResolution_=e,(0,b.xb)(i)))return;const o=(0,b.qg)(i),u=e*e/4;(!this.projection_||!(0,E.OP)(this.projection_,n))&&this.updateProjectionInfo_(n),this.createGraticule_(i,o,e,u);let r,d=this.meridians_.length+this.parallels_.length;for(this.meridiansLabels_&&(d+=this.meridians_.length),this.parallelsLabels_&&(d+=this.parallels_.length);d>this.featurePool_.length;)r=new K.Z,this.featurePool_.push(r);const p=a.getFeaturesCollection();p.clear();let h,m,S=0;for(h=0,m=this.meridians_.length;h<m;++h)r=this.featurePool_[S++],r.setGeometry(this.meridians_[h]),r.setStyle(this.lineStyle_),p.push(r);for(h=0,m=this.parallels_.length;h<m;++h)r=this.featurePool_[S++],r.setGeometry(this.parallels_[h]),r.setStyle(this.lineStyle_),p.push(r)}addMeridian_(t,e,n,a,s,i){const o=this.getMeridian_(t,e,n,a,i);if((0,b.kK)(o.getExtent(),s)){if(this.meridiansLabels_){const u=this.lonLabelFormatter_(t);i in this.meridiansLabels_?this.meridiansLabels_[i].text=u:this.meridiansLabels_[i]={geom:new Y.Z([]),text:u}}this.meridians_[i++]=o}return i}addParallel_(t,e,n,a,s,i){const o=this.getParallel_(t,e,n,a,i);if((0,b.kK)(o.getExtent(),s)){if(this.parallelsLabels_){const u=this.latLabelFormatter_(t);i in this.parallelsLabels_?this.parallelsLabels_[i].text=u:this.parallelsLabels_[i]={geom:new Y.Z([]),text:u}}this.parallels_[i++]=o}return i}drawLabels_(t){const e=t.frameState.viewState.rotation,n=t.frameState.viewState.resolution,a=t.frameState.size,s=t.frameState.extent,i=(0,b.qg)(s);let o=s;if(e){const h=a[0]*n,m=a[1]*n;o=[i[0]-h/2,i[1]-m/2,i[0]+h/2,i[1]+m/2]}let u=0,_=0,d=this.latLabelPosition_<.5;const r=this.projection_.getExtent(),p=(0,b.dz)(r);this.getSource().getWrapX()&&this.projection_.canWrapX()&&!(0,b.r4)(r,s)&&(u=Math.floor((s[0]-r[0])/p),_=Math.ceil((s[2]-r[2])/p),d=d!==Math.abs(e)>Math.PI/2);const S=(0,$.u3)(t);for(let h=u;h<=_;++h){let f,c,y,P,m=this.meridians_.length+this.parallels_.length;if(this.meridiansLabels_)for(c=0,y=this.meridiansLabels_.length;c<y;++c){const M=this.meridians_[c];if(e||0!==h){const x=M.clone();x.translate(h*p,0),x.rotate(-e,i),P=this.getMeridianPoint_(x,o,c),P.rotate(e,i)}else P=this.getMeridianPoint_(M,s,c);f=this.featurePool_[m++],f.setGeometry(P),f.set("graticule_label",this.meridiansLabels_[c].text),S.drawFeature(f,this.lonLabelStyle_(f))}if(this.parallelsLabels_&&(h===u&&d||h===_&&!d))for(c=0,y=this.parallels_.length;c<y;++c){const M=this.parallels_[c];if(e||0!==h){const x=M.clone();x.translate(h*p,0),x.rotate(-e,i),P=this.getParallelPoint_(x,o,c),P.rotate(e,i)}else P=this.getParallelPoint_(M,s,c);f=this.featurePool_[m++],f.setGeometry(P),f.set("graticule_label",this.parallelsLabels_[c].text),S.drawFeature(f,this.latLabelStyle_(f))}}}createGraticule_(t,e,n,a){const s=this.getInterval_(n);if(-1==s)return this.meridians_.length=0,this.parallels_.length=0,this.meridiansLabels_&&(this.meridiansLabels_.length=0),void(this.parallelsLabels_&&(this.parallelsLabels_.length=0));let i=!1;const o=this.projection_.getExtent(),u=(0,b.dz)(o);this.getSource().getWrapX()&&this.projection_.canWrapX()&&!(0,b.r4)(o,t)&&((0,b.dz)(t)>=u?(t[0]=o[0],t[2]=o[2]):i=!0);const _=[(0,v.uZ)(e[0],this.minX_,this.maxX_),(0,v.uZ)(e[1],this.minY_,this.maxY_)],d=this.toLonLatTransform_(_);isNaN(d[1])&&(d[1]=Math.abs(this.maxLat_)>=Math.abs(this.minLat_)?this.maxLat_:this.minLat_);let r=(0,v.uZ)(d[0],this.minLon_,this.maxLon_),p=(0,v.uZ)(d[1],this.minLat_,this.maxLat_);const S=this.maxLines_;let h,m,f,c,y=t;i||(y=[(0,v.uZ)(t[0],this.minX_,this.maxX_),(0,v.uZ)(t[1],this.minY_,this.maxY_),(0,v.uZ)(t[2],this.minX_,this.maxX_),(0,v.uZ)(t[3],this.minY_,this.maxY_)]);const P=(0,b.Ne)(y,this.toLonLatTransform_,void 0,8);let M=P[3],x=P[2],Z=P[1],j=P[0];if(i||((0,b.b8)(y,this.bottomLeft_)&&(j=this.minLon_,Z=this.minLat_),(0,b.b8)(y,this.bottomRight_)&&(x=this.maxLon_,Z=this.minLat_),(0,b.b8)(y,this.topLeft_)&&(j=this.minLon_,M=this.maxLat_),(0,b.b8)(y,this.topRight_)&&(x=this.maxLon_,M=this.maxLat_),M=(0,v.uZ)(M,p,this.maxLat_),x=(0,v.uZ)(x,r,this.maxLon_),Z=(0,v.uZ)(Z,this.minLat_,p),j=(0,v.uZ)(j,this.minLon_,r)),r=Math.floor(r/s)*s,c=(0,v.uZ)(r,this.minLon_,this.maxLon_),m=this.addMeridian_(c,Z,M,a,t,0),h=0,i)for(;(c-=s)>=j&&h++<S;)m=this.addMeridian_(c,Z,M,a,t,m);else for(;c!=this.minLon_&&h++<S;)c=Math.max(c-s,this.minLon_),m=this.addMeridian_(c,Z,M,a,t,m);if(c=(0,v.uZ)(r,this.minLon_,this.maxLon_),h=0,i)for(;(c+=s)<=x&&h++<S;)m=this.addMeridian_(c,Z,M,a,t,m);else for(;c!=this.maxLon_&&h++<S;)c=Math.min(c+s,this.maxLon_),m=this.addMeridian_(c,Z,M,a,t,m);for(this.meridians_.length=m,this.meridiansLabels_&&(this.meridiansLabels_.length=m),p=Math.floor(p/s)*s,f=(0,v.uZ)(p,this.minLat_,this.maxLat_),m=this.addParallel_(f,j,x,a,t,0),h=0;f!=this.minLat_&&h++<S;)f=Math.max(f-s,this.minLat_),m=this.addParallel_(f,j,x,a,t,m);for(f=(0,v.uZ)(p,this.minLat_,this.maxLat_),h=0;f!=this.maxLat_&&h++<S;)f=Math.min(f+s,this.maxLat_),m=this.addParallel_(f,j,x,a,t,m);this.parallels_.length=m,this.parallelsLabels_&&(this.parallelsLabels_.length=m)}getInterval_(t){const e=this.projectionCenterLonLat_[0],n=this.projectionCenterLonLat_[1];let a=-1;const s=Math.pow(this.targetSize_*t,2),i=[],o=[];for(let u=0,_=this.intervals_.length;u<_;++u){const d=(0,v.uZ)(this.intervals_[u]/2,0,90),r=(0,v.uZ)(n,-90+d,90-d);if(i[0]=e-d,i[1]=r-d,o[0]=e+d,o[1]=r+d,this.fromLonLatTransform_(i,i),this.fromLonLatTransform_(o,o),Math.pow(o[0]-i[0],2)+Math.pow(o[1]-i[1],2)<=s)break;a=this.intervals_[u]}return a}getMeridian_(t,e,n,a,s){const i=function k(g,t,e,n,a){const s=(0,E.U2)("EPSG:4326");return F(function(i){return[g,t+(e-t)*i]},(0,E.Ck)(s,n),a)}(t,e,n,this.projection_,a);let o=this.meridians_[s];return o?(o.setFlatCoordinates("XY",i),o.changed()):(o=new W.Z(i,"XY"),this.meridians_[s]=o),o}getMeridianPoint_(t,e,n){const a=t.getFlatCoordinates();let s=1,i=a.length-1;a[s]>a[i]&&(s=i,i=1);const o=Math.max(e[1],a[s]),u=Math.min(e[3],a[i]),_=(0,v.uZ)(e[1]+Math.abs(e[1]-e[3])*this.lonLabelPosition_,o,u),p=this.meridiansLabels_[n].geom;return p.setCoordinates([a[s-1]+(a[i-1]-a[s-1])*(_-a[s])/(a[i]-a[s]),_]),p}getMeridians(){return this.meridians_}getParallel_(t,e,n,a,s){const i=function q(g,t,e,n,a){const s=(0,E.U2)("EPSG:4326");return F(function(i){return[t+(e-t)*i,g]},(0,E.Ck)(s,n),a)}(t,e,n,this.projection_,a);let o=this.parallels_[s];return o?(o.setFlatCoordinates("XY",i),o.changed()):o=new W.Z(i,"XY"),o}getParallelPoint_(t,e,n){const a=t.getFlatCoordinates();let s=0,i=a.length-2;a[s]>a[i]&&(s=i,i=0);const o=Math.max(e[0],a[s]),u=Math.min(e[2],a[i]),_=(0,v.uZ)(e[0]+Math.abs(e[0]-e[2])*this.latLabelPosition_,o,u),p=this.parallelsLabels_[n].geom;return p.setCoordinates([_,a[s+1]+(a[i+1]-a[s+1])*(_-a[s])/(a[i]-a[s])]),p}getParallels(){return this.parallels_}updateProjectionInfo_(t){const e=(0,E.U2)("EPSG:4326"),n=t.getWorldExtent();this.maxLat_=n[3],this.maxLon_=n[2],this.minLat_=n[1],this.minLon_=n[0];const a=(0,E.Ck)(t,e);if(this.minLon_<this.maxLon_)this.toLonLatTransform_=a;else{const i=this.minLon_+this.maxLon_/2;this.maxLon_+=360,this.toLonLatTransform_=function(o,u,_){const d=a(o,u,_=_||2);for(let r=0,p=d.length;r<p;r+=_)d[r]<i&&(d[r]+=360);return d}}this.fromLonLatTransform_=(0,E.Ck)(e,t);const s=(0,b.Ne)([this.minLon_,this.minLat_,this.maxLon_,this.maxLat_],this.fromLonLatTransform_,void 0,8);this.minX_=s[0],this.maxX_=s[2],this.minY_=s[1],this.maxY_=s[3],this.bottomLeft_=this.fromLonLatTransform_([this.minLon_,this.minLat_]),this.bottomRight_=this.fromLonLatTransform_([this.maxLon_,this.minLat_]),this.topLeft_=this.fromLonLatTransform_([this.minLon_,this.maxLat_]),this.topRight_=this.fromLonLatTransform_([this.maxLon_,this.maxLat_]),this.projectionCenterLonLat_=this.toLonLatTransform_((0,b.qg)(t.getExtent())),isNaN(this.projectionCenterLonLat_[1])&&(this.projectionCenterLonLat_[1]=Math.abs(this.maxLat_)>=Math.abs(this.minLat_)?this.maxLat_:this.minLat_),this.projection_=t}};var st=L(8618),nt=L(5504),l=L(3714),ot=L(285),z=L(4595),T=L(7243),lt=L(3254),rt=L(2227),ht=L(911);let ct=(()=>{class g{constructor(e,n,a,s){this.layersSvc=e,this.mapStateSvc=n,this.mapOlSvc=a,this.mapThreeSvc=s,this.class="content-container",this.controls={attribution:!0,mousePosition:!0,scaleLine:!0,zoom:!0}}ngOnInit(){const e=new nt.Z({source:new st.Z({url:"https://planetarymaps.usgs.gov/cgi-bin/mapserv?map=/maps/mars/phobos_simp_cyl.map",params:{LAYERS:"VIKING"},crossOrigin:"anonymous"})}),n=new it({showLabels:!0,wrapX:!0,latLabelPosition:.5}),a=new C.AO({id:"phobos",name:"Phobos",custom_layer:e,description:"There are a few objects that are very big, but still irregularly shaped.\n      Because they are big, it makes sense to serve their image-material per WMTS instead of a single, humongous file.\n      Because they are irregularly shaped, it makes sense to display them in 3d.\n\n      This demo shows how we can project openlayers-layers onto a three-js mesh to reap the benefits of both libraries."}),s=new C.AO({id:"graticule",name:"Graticule",custom_layer:n,description:"Note how adding and removing this layer is reflected in both the map and the 3d-object."});this.layersSvc.addLayer(a),this.layersSvc.addLayer(s)}ngAfterViewInit(){const e=(0,E.U2)("EPSG:4326");this.mapOlSvc.setProjection(e),this.mapOlSvc.map.getView().setMaxZoom(4)}static#t=this.\u0275fac=function(n){return new(n||g)(l.Y36(C.KD),l.Y36(ot.I3),l.Y36(w.BR),l.Y36(z.qO))};static#e=this.\u0275cmp=l.Xpm({type:g,selectors:[["app-route-example-threejs"]],hostVars:2,hostBindings:function(n,a){2&n&&l.Tol(a.class)},features:[l._Bn([C.KD,w.BR])],decls:25,vars:10,consts:[[1,"content-area","map-view"],[2,"height","49.5%","width","100%"],["id","olMap",3,"layersSvc","mapState","controls"],[2,"height","50%","width","100%"],["id","threeMap",3,"mapOlSvc"],[1,"right",3,"clrVerticalNavCollapsible","clr-nav-level"],[1,"layers",3,"clrVerticalNavGroupExpanded"],["shape","info","clrVerticalNavIcon","","title","layers"],[1,"padding","title-ellipsis"],[1,"card",2,"margin","0px","margin-bottom","10px"],[1,"card-block"],[1,"card-text"],["shape","layers","clrVerticalNavIcon","","title","layers"],[1,"alert-item","static"],[1,"alert-text"],[3,"layersSvc","mapStateSvc"]],template:function(n,a){1&n&&(l.TgZ(0,"main",0)(1,"div",1),l._UZ(2,"ukis-map-ol",2),l.qZA(),l.TgZ(3,"div",3),l._UZ(4,"ukis-map-three",4),l.qZA()(),l.TgZ(5,"clr-vertical-nav",5)(6,"clr-vertical-nav-group",6),l._UZ(7,"clr-icon",7),l._uU(8," Phobos "),l.TgZ(9,"clr-vertical-nav-group-children",8)(10,"div",9)(11,"div",10)(12,"div",11)(13,"p"),l._uU(14," This is a threejs/openlayers demo application. Here, we project an openlayers map as a canvas-texture onto a glTF model of the Mars-moon Phobos. "),l.qZA(),l.TgZ(15,"p"),l._uU(16," There are some objects that are so irregular that they are better displayed with a three dimensional model, yet so large that their imagedata is best served per WMTS. Phobos is a good example of such an object. Note how the texture gets sharper when you zoom in: this is a new WMTS tile being loaded, projected and displayed on the fly. "),l.qZA()()()()()(),l.TgZ(17,"clr-vertical-nav-group",6),l._UZ(18,"clr-icon",12),l._uU(19," Layers "),l.TgZ(20,"clr-vertical-nav-group-children",8)(21,"div",13)(22,"span",14),l._uU(23," The controls of map and 3d-object are synced. Use the mouse to pan around in either and watch both displays change. "),l.qZA()(),l._UZ(24,"ukis-layer-control",15),l.qZA()()()),2&n&&(l.xp6(2),l.Q6J("layersSvc",a.layersSvc)("mapState",a.mapStateSvc)("controls",a.controls),l.xp6(2),l.Q6J("mapOlSvc",a.mapOlSvc),l.xp6(1),l.Q6J("clrVerticalNavCollapsible",!0)("clr-nav-level",2),l.xp6(1),l.Q6J("clrVerticalNavGroupExpanded",!0),l.xp6(11),l.Q6J("clrVerticalNavGroupExpanded",!0),l.xp6(7),l.Q6J("layersSvc",a.layersSvc)("mapStateSvc",a.mapStateSvc))},dependencies:[T.I9z,T.qvL,T.saT,T.fzC,T.A0B,T.d6G,T.ogR,lt.E,rt.j,ht.X]})}return g})();var mt=L(2233);const dt=[{path:"",component:ct}];let O=(()=>{class g{static#t=this.\u0275fac=function(n){return new(n||g)};static#e=this.\u0275mod=l.oAB({type:g});static#a=this.\u0275inj=l.cJS({imports:[B.Bz.forChild(dt),B.Bz]})}return g})(),Lt=(()=>{class g{static#t=this.\u0275fac=function(n){return new(n||g)};static#e=this.\u0275mod=l.oAB({type:g});static#a=this.\u0275inj=l.cJS({imports:[U.ez,V.q,O,T.K6A,mt.cE,w.oC,z.fB]})}return g})()}}]);